# 結合  
テーブルとテーブルをつなげて新しいテーブルを作り出すという基本動作はシンプル。  
結合を制するものがSQLを制する。  

## 結合の種類  

- クロス結合(cross join)  
実務で使う機会はほとんど無い。  
SQLにおける結合という演算を理解するには、クロス結合を知ることが早道。  
- 内部結合
- 外部結合
- 自己結合
- 等値結合/非等値結合
- 自然結合

### クロス結合  

以下サンプルを用いる。  

```sql
CREATE TABLE Employees  
(emp_id CHAR(8),  
 emp_name VARCHAR(32),  
 dept_id CHAR(2),  
     CONSTRAINT pk_emp PRIMARY KEY(emp_id));  

CREATE TABLE Departments  
(dept_id CHAR(2),  
 dept_name VARCHAR(32),  
     CONSTRAINT pk_dep PRIMARY KEY(dept_id));  

CREATE INDEX idx_dept_id ON Employees(dept_id);  

INSERT INTO Employees VALUES('001',	'石田',	  '10');  
INSERT INTO Employees VALUES('002',	'小笠原', '11');  
INSERT INTO Employees VALUES('003',	'夏目',	  '11');  
INSERT INTO Employees VALUES('004',	'米田',	  '12');  
INSERT INTO Employees VALUES('005',	'釜本',	  '12');  
INSERT INTO Employees VALUES('006',	'岩瀬',	  '12');  

INSERT INTO Departments VALUES('10',	'総務');  
INSERT INTO Departments VALUES('11',	'人事');  
INSERT INTO Departments VALUES('12',	'開発');  
INSERT INTO Departments VALUES('13',	'営業');  
commit;  
```

社員およびその所属部署を管理するテーブル。  
この2つに対してクロス結合を行う。  

```sql
SELECT *  
   FROM Employees  
          CROSS JOIN  
		Departments;  
```

このSQLの実行結果は24行。  
社員テーブルの行数6と、部署テーブルの行数4のかけ算になる。  

数学的には直積、デカルト積と呼ばれる演算で、結合対象となる2つのテーブルのレコードから、  
可能なすべての組合せ網羅する演算。

#### クロス結合は実務では使われない理由  

- 実際にこういう結果を求めたいケースがない
- 非常にコストがかかる演算

#### うっかりクロス結合  

古い結合構文を使ってうっかり結合条件を書き忘れたときにクロス結合になってしまう。  

```sql
SELECT *  
  FROM Employees, Departments;  
```

結合条件がないため、DBMSはしかたなくテーブル同士の全行を組み合わせようとする。  
実務では、3つ以上のテーブルを結合したり、結合条件を複数書くことがある。そういう時にやってしまいがち。  

防ぐためには、標準SQL準拠の結合構文を使うようコーディング規約を定めること。  
`INNER JOIN`のような標準SQLの構文では、結合条件がないとDBMSは構文エラーとして実行を拒否するので、こうしたミスを未然に防げる。  

とはいえ、クロス結合はほかの全ての演算の母体。

### 内部結合  

内部結合(INNER JOIN)は一番よく使う結合の種類。  

#### 内部結合の動作  

以下サンプル(再掲)を使う。  

```sql
CREATE TABLE Employees  
(emp_id CHAR(8),  
 emp_name VARCHAR(32),  
 dept_id CHAR(2),  
     CONSTRAINT pk_emp PRIMARY KEY(emp_id));  

CREATE TABLE Departments  
(dept_id CHAR(2),  
 dept_name VARCHAR(32),  
     CONSTRAINT pk_dep PRIMARY KEY(dept_id));  

CREATE INDEX idx_dept_id ON Employees(dept_id);  

INSERT INTO Employees VALUES('001',	'石田',	  '10');  
INSERT INTO Employees VALUES('002',	'小笠原', '11');  
INSERT INTO Employees VALUES('003',	'夏目',	  '11');  
INSERT INTO Employees VALUES('004',	'米田',	  '12');  
INSERT INTO Employees VALUES('005',	'釜本',	  '12');  
INSERT INTO Employees VALUES('006',	'岩瀬',	  '12');  

INSERT INTO Departments VALUES('10',	'総務');  
INSERT INTO Departments VALUES('11',	'人事');  
INSERT INTO Departments VALUES('12',	'開発');  
INSERT INTO Departments VALUES('13',	'営業');  
commit;  
```

これらテーブルを内部結合してみる。  

```sql
SELECT  
  E.emp_id,  
  E.emp_name,  
  E.dept_id,  
  D.dept_name  
 FROM Employees E INNER JOIN Departments D  
   ON E.dept_id = D.dept_id;  
```

この結果と、クロス結合を見比べてみると、内部結合の結果は、そのすべてがクロス結合の一部、つまり部分集合になっている。  
内部結合という語の由来は上記から。内部とは「直積の部分集合」の意味。  

#### 内部結合と同値の相関サブクエリ  

内部結合は、機能的に相関サブクエリを使って代替可能なことが多くある。  
前述のINNER JOINを相関サブクエリに書きかえてみる。  

```sql
SELECT  
  E.emp_id,  
  E.emp_name,  
  E.dept_id,  
  (SELECT 
     D.dept_name
	FROM Departments D
   WHERE E.dept_id = D.dept_id) AS dept_name  
 FROM Employees E;  
```

基本的に結合で記述できる限りは結合を選択すると良い。  
相関サブクエリをスカラサブクエリ(戻り値が単一の値になるクエリ)と使うと、  
結果行数の数だけサブクエリを実行することになるのでコストがかかる。  

### 外部結合  

外部結合(outer join)は、内部結合の次によく使われる。  
「内部」と「外部」は排他的な関係。  
「外部」とは「直積の部分集合」にならない、という意味。  
ただし、常に部分集合にならない、というわけではない。データの状態によってそういうこともある。  

#### 外部結合の動作  

外部結合は次の3つがある。  

- 左外部結合
- 右外部結合
- 完全外部結合


このうち、左外部結合と右外部結合は実質的には同じ機能。  
マスタとなるテーブルを左に書くなら左外部結合、右に書くなら右外部結合、という話。  

```sql
-- 左のテーブルがマスタ
SELECT  
  E.emp_id,  
  E.emp_name,  
  E.dept_id,  
  D.dept_name  
 FROM Departments D LEFT OUTER JOIN Employees E  
   ON E.dept_id = D.dept_id;  
   
-- 右のテーブルがマスタ
SELECT  
  E.emp_id,  
  E.emp_name,  
  E.dept_id,  
  D.dept_name  
 FROM Employees E RIGHT OUTER JOIN Departments D  
   ON E.dept_id = D.dept_id;  
```
  
実行結果の最終行を見ると、外部結合の結果には、マスタ側のテーブルだけに存在するキーがあった場合、  
そのキーを削除せず、結果に保存するよう動作する。  
そのため、キーの値をすべて網羅するレイアウトのレポートを作る場合に多用される。  

### 外部結合と内部結合の違い  

実行結果のうち、違うのは最終行のみ。  
これは、内部結合、クロス結合の結果のどの行とも一致しない。いわば「外部」にはみだしている。  

外部結合の結果がクロス結合の結果の部分集合にならないのは、外部結合がマスタ側のテーブルの情報を保存するよう動作し、  
その結果NULLを生成するため。  
一方、クロス結合や内部結合は、NULLを生成することはない。  

### 自己結合  

自己結合(self join)は、文字どおり自分自身と結合する演算で、同じテーブルあるいは同じビューを使って結合を行うもの。  
クロス結合/内部結合/外部結合とはちょっと毛色が違う。  
自己結合とは、生成される結果を基準とした分類ではなく、演算の対象に何を使うかという点が問題になってくる。  
そのため、自己結合は、「自己結合 + クロス結合」、「自己結合 + 外部結合」といったふうに他の結合との組み合わせが可能。  

#### 自己結合の動作  

```sql
CREATE TABLE Digits
(digit INTEGER PRIMARY KEY);

INSERT INTO Digits VALUES(0);
INSERT INTO Digits VALUES(1);
INSERT INTO Digits VALUES(2);
INSERT INTO Digits VALUES(3);
INSERT INTO Digits VALUES(4);
INSERT INTO Digits VALUES(5);
INSERT INTO Digits VALUES(6);
INSERT INTO Digits VALUES(7);
INSERT INTO Digits VALUES(8);
INSERT INTO Digits VALUES(9);
commit;
```

自己結合 + クロス結合

```sql
SELECT
  D1.digit + (D2.digit * 10) AS seq
 FROM Digits D1 CROSS JOIN Digits D2 ORDER BY seq;
```

結合対象は、Digits(D1)とDigits(D2)なので、10 * 10 = 100行になる。  

#### 自己結合の考え方  
自己結合を行う場合、一般的に同じテーブルに別名をつけて、それらをあたかも別テーブルであるかのように扱う。  

### 結合のアルゴリズムとパフォーマンス  

SQLで結合演算を行う場合、内部で選択されるアルゴリズムを基準にして考えてみる。  
オプティマイザが選択可能な結合アルゴリズムは大きく次の3つがある。  

1. Nested Loops
2. Hash
3. Sort Merge

最も頻繁に見るのがNested Loop、次に重要なのはHash。  

#### Nested Loops  

Nested Loopsは名前のとおり入れ子のループを使うアルゴリズム。  
結合は常に1度につき2つのテーブルしか結合しないため、実質的には二重ループと同じ意味。  

Nested Loopsには、次のような特徴がある。  

- Table_A, Table_Bの結合対象の行数をR(A), R(B)とすると、アクセスされる行数はR(A) * R(B)となる。
  Nested Loopsの実行時間はこの行数に比例する。
- 1つのステップで処理する行数が少ないため、HashやSort Mergeと比べてあまりメモリを消費しない
- どのDBMSでも必ずサポートしている


Nested Loopsは一見単純に見えるが、結合のパフォーマンスの鍵を握っていると言っても過言ではない重要なアルゴリズム。  
特にA, Bどちらのテーブルを駆動表にするかが大きな要因となる。  
どちらが駆動表でも、R(A) * R(B), R(B) * R(A)で変わらないように思えるが、実際には駆動表が小さいほどNested Loopsの性能は良くなる。  

##### 駆動表の重要性  

Nested Loopsの性能を改善するキーワードとして、駆動表に小さなテーブルを選ぶ、というのがあるが、実際にはある前提条件が無いと意味がない。  

`内部表の結合キーの列にインデックスが存在すること`  

内部表の結合キーの列にインデックスが存在する場合、そのインデックスをたどることによって、DBMSは駆動表の1行に対して内部表を馬鹿正直にループする必要がなくなる。  

理想的なケースでは、駆動表のレコード1行に対して内部表レコードが1行に対応していれば、インデックスを辿ることで1行を特定できるため、  
完全に内部表のループを省略出来る。  
アクセス行数は、R(A) * 2となる。  

しかし、内部表の結合キーのインデックスが使われないと、駆動表を小さくするメリットが少なくなる。  

内部表のループを完全にスキップ出来るのは、結合キーが内部表に対して一意な場合だけ。  
等値結合であれば、内部表のアクセス対象行を必ず1行に限定出来るので、二重ループの内側のループを完全に省略出来る。  

一方、結合キーが内部表に対して一意でない場合、インデックスで内部表にアクセスする場合でも、  
複数行がヒットする可能性がある。  
この場合は、そのヒットした複数行に対してループする必要がある。  


「駆動表」を小さく、という格言は、「内部表を大きく」というふうに解釈するのがよいかもしれない。  
内部表が大きいほどインデックスによるループのスキップ効果が大きくなるから。  

「駆動表の小さなNested Loops」 + 「内部表の結合キーにインデックス」、という組み合わせは、SQLチューニングにおける基本中の基本。  
結合が遅い場合の半分は上記組み合わせによって改善出来る。  

物理ERモデルとインデックスの設計を行う時、どのテーブルを内部表にして、どの結合キーにインデックスを作成しておくべきか、  
設計の段階から考えておく必要がある。

##### Nested Loopsの落とし穴  

結合キーで内部表にアクセスしたときのヒット件数が多いと、期待したようなレスポンスが出ないことがある。  
いかにインデックスをたどったとしても、絶対量としてのループ回数が多ければ意味がない。  

店舗テーブルと、そこで注文を受けつけるテーブルがあるとする。  
この場合、1つの店舗に対して複数の注文が対応するので、店舗テーブルのほうが駆動表にふさわしいと仮定する。  
すると、店舗IDを結合キーとして注文テーブルにアクセスする。  
たとえば、そこで1つの店舗IDで数百万、数千万件のレコードがヒットしてしまうと、結局は内部表に対するループ回数が多くなる。  
店舗というのは、地域や規模によって注文数に開きがあるため、小規模の店舗であれば注文少なく高速に処理されるが、  
大規模の店舗だと注文多く大量の結果がヒットしてしまい、まったく結果が帰ってこないことになりかねない。  

SQLのパフォーマンスは処理対象となるデータの量に依存する。  

この問題に対処する方法は2つある。  
1つは、あえて駆動表に大きなテーブルを置く。  
内部表になった店舗テーブルのアクセスは、主キー(店舗ID)になるので常に1行のアクセスが保証される。  
店舗によって性能のばらつきを抑えつつ、極端に性能が劣化するのを防ぐ方法。  
注文テーブルという巨大テーブルへのアクセスコストが(検索条件によるインデックスが使えるなどで)現実的な範囲に収まるならば、有効な方法。  
もう1つの方法がHash。

### Hash  

Hashはアルゴリズムの世界ではよく使われる。  
入力に対しなるべく一意性と一様性を持った値を出力する関数をハッシュ関数と言う。  

ハッシュ結合は、まず小さいテーブルをスキャンし、結合キーに対してハッシュ関数を適用することでハッシュ値に変換する。  
このハッシュ値の集合をハッシュテーブルと呼ぶ。  
次に、もう一方の(大きな)テーブルをスキャンして、結合キーがそのハッシュ値に存在するかどうか調べるという方法で結合を行う。  

小さいほうのテーブルからハッシュテーブルを作る理由は、ハッシュテーブルはDBMSのワーキングメモリに保存されるため、  
なるべく小さなテーブルのほうが効率良い。  

Hashの特徴は次のとおり。  

- メモリを多く消費する
結合テーブルからハッシュテーブルを作るため。
- TEMP落ちが発生するかもしれない
メモリ内にハッシュテーブルが収まらないとストレージを使用してしまう
- 出力となるハッシュ値は入力値の順序性を保証しないため、等値結合でしか使えない


Hashが有効なケースは次のとおり。  

- Nested Loopsで適切な駆動表が存在しない場合
- 駆動表として小さなテーブルは指定できるが内部表のヒット件数が多い場合
- 内部表にインデックスが無い、かつインデックスを追加出来ない場合


一般的に、Nested Loopsが効率的に動作しない場合の改善策がHash。  
しかし、メモリ消費の大きさ、OLTPでの遅延を考慮すると、  
夜間バッチや、スループットの低いシステムに使いどころを限定する必要がある。  

### Sort Merge  

Nested Loopsが非効率な場合、Hashと並んで選択肢になるのがSort Mergeというアルゴリズム。  
Sort Mergeは、結合対象のテーブルをそれぞれ結合キーでソートを行い、一致する結合キーを見つけたらそれを結果セットに含める、というもの。  

#### Sort Mergeの特徴  

- Nested Loopsよりも多くのメモリを消費する
- 不等号を使った結合にも利用できる、ただし、否定条件の結合では利用できない
- ソート済みのテーブルであればソートをスキップ出来る
- テーブルをソートするため、片方のテーブルをすべてスキャンしたところで結合を終了出来る


#### Sort Mergeが有効なケース  

Sort Mergeの結合は、結合そのものにかかる時間は結合の対象行数が多い場合でも悪くない。  
しかし、テーブルのソートに多くの時間とリソースを使う可能性がある。  
テーブルのソートをスキップ出来る(かなり例外的な)ケースでは、検討の価値があるが、  
まずはNested Looopsと、Hashが優先的な選択肢になる。  

### 意図せぬクロス結合  

クロス結合を実務で使うことはほぼ無いが、意図せずしてクロス結合が現われることがある。  
これを「三角結合」という。

```sql
SELECT  
   A.col_a,  
   B.col_b,  
   C.col_c  
  FROM Table_A A  
       INNER JOIN Table_B B  
	      ON A.col_a = B.col_b  
	   INNER JOIN Table_C C  
	      ON A.col_a = C.col_c;  
```

このSQLでは、Table_A, Table_B, Table_Cの3つのテーブルを結合しているが、  
結合条件が存在するのは、Table_A - Table_B, Table_A - Table_Cの間。  

Table_B <-> Table_A <-> Table_C

このSQLを実行すると、実行計画に'MERGE JOIN CARTESIAN'が出る。これがクロス結合。  

結合条件の無いテーブル同士をクロス結合で結合するケースがある。  
Table_BとTable_Cを最初に結合し、その結果をTable_Aと結合する、という順番でやっている。  
Table_BとTable_Cは、結合条件がないためクロス結合するしかない。  

取引明細などの大きなテーブルと、顧客やカレンダーなどの小さなマスタテーブルを結合するようなパターンがある。  
小さなテーブルでのクロス結合はそれほど問題にはならないが、比較的大きなテーブルでは気をつける必要がある。  
単純にテーブルのサイズだけではなく、検索条件によってヒットするレコードが変わる場合にも起きる。  

#### 意図せぬクロス結合の回避  

結合条件の存在しないテーブルにも(結果を変えないように)結合条件を追加する。  
Table_B, Table_Cの間に結合条件を追加する。  

```sql
SELECT  
   A.col_a,  
   B.col_b,  
   C.col_c  
  FROM Table_A A  
       INNER JOIN Table_B B  
	      ON A.col_a = B.col_b  
	   INNER JOIN Table_C C  
	      ON A.col_a = C.col_c  
		 AND C.col_c = B.col_b;  
```

これだと、`MERGE JOIN CARTESIAN`が出ない。

### 結合が遅いなと感じたら  

オプティマイザは、それぞれの結合アルゴリズムの利点と欠点を考慮しながらアルゴリズムを選択している。  
しかし、結合アルゴリズムが最適化されず遅延が発生することがある。  

最適な結合アルゴリズムを結合対象行数の観点でまとめると、以下のようになる。

- テーブル小・テーブル小
  どんなアルゴリズムでも性能に大差はない
- テーブル小・テーブル大
  テーブル小を駆動表とするNested Loops。テーブル大の結合キーにインデックスを作ること。
  ただし、内部表の行数が多い場合は、駆動表をひっくりかえすかHashを検討する。
- テーブル大・テーブル大
  まずはHash。結合キーがソート済みという前提であれば、Sort Merge.
  
#### そもそも実行計画の制御は可能なのか  

内部表の結合キーにインデックスを作ればNested Loopsで使ってくれる、程度であればどのDBMSでもやってくれる。  
それ以上の制御は?

##### DBMSごとの実行計画制御

- Oracle
  ヒント句により結合アルゴリズムの制御が可能(USE_NL, USE_HASH, USE_MERGE)
  駆動表の制御も可能(LEADING)
- SQL Server
  ヒント句により結合アルゴリズムの制御が可能
- DB2
  なし
- PostgreSQL
  pg_hint_planによりヒント句による結合アルゴリズムの制御が可能
  また、サーバパラメータによりデータベース全体の制御が可能
- MySQL
  結合アルゴリズムがNested Loopsしかない。
  

##### 実行計画をユーザが制御することによるリスク  

ある時点において最適な実行計画が、別時点においてはそうならないケースがある。  
もともと、そのために導入されたのがコストベースによる動的な実行計画の制御。  

そうしたリスクを十分に検討したうえで、予期されるシステムのライフサイクルの終了時点にも、  
なお適切な実行計画を選択し、その時点のデータ特性を擬似的に表現したデータによって性能試験を実施するという実行コストの高いチューニングが必要。

##### 実行計画は揺れるよ  

オプティマイザの失敗の典型例は、長期的な運用の中で実行計画が悪い方向に変動していくもの。  
データ量の増加などによって統計情報が変化し、ある一定の閾値を越えたところでオプティマイザが実行計画を変化させることで起きる。  
事前に発生予測が難しく、突発的なスローダウンを引きおこしてしまう。  

実行計画を最も引き起しやすい演算が結合。  
SQLの性能変動リスクをおさえるためには、なるべく結合をしないことが重要。  
同じ結果を得るためのSQLであっても、結合を使用せず代替手段で対応できる。  
ウィンドウ関数、相関サブクエリで対応もできる。  
